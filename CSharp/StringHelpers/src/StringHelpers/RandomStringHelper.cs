using System.Buffers;
using System.Runtime.CompilerServices;
using System.Security.Cryptography;
using Microsoft.AspNetCore.WebUtilities;

[assembly: InternalsVisibleTo("StringHelpers.Tests")]

namespace StringHelpers;

public static class RandomStringHelper
{
    // These are internal so that we can see them in unit tests.
    internal const string AlphabetLower = "abcdefghijklmnopqrstuvwxyz";
    internal const string Digits = "0123456789";
    internal const string Symbols = "`~!@#$%^&*()-_=+[{]}\\|;:'\",<.>/?";

    private static readonly char[] _alphanumeric;
    internal static readonly char[] _alphanumericPlusDashUnderscore;
    private static readonly char[] _alphanumericPlusSymbols;
    private static readonly char[] _uppercaseAlphanumeric;


    static RandomStringHelper()
    {
        _alphanumeric = [
            .. AlphabetLower,
            .. AlphabetLower.ToUpper(),
            .. Digits,
            ];

        _alphanumericPlusDashUnderscore = [
            .. _alphanumeric,
            '-',
            '_',
            ];

        // Symbols includes dash and underscore.
        _alphanumericPlusSymbols = [
            .. _alphanumeric,
            .. Symbols,
            ];

        _uppercaseAlphanumeric = [
            .. AlphabetLower.ToUpper(),
            .. Digits
            ];
    }


    /// <summary>
    /// Generates a cryptographically-strong array of random bytes and return them as a base64 url-encoded string. 
    /// </summary>
    /// <remarks>The underlying <see cref="WebEncoders.Base64UrlEncode(ReadOnlySpan{byte})"/> removes any padding characters.</remarks>
    /// <param name="byteCount">The number of random bytes to generate.</param>
    /// <returns>The random bytes as a base64 url-encoded string.</returns>
    public static string GenerateRandomBase64UrlEncodedString(int byteCount)
    {
        ArgumentOutOfRangeException.ThrowIfLessThanOrEqual(byteCount, 0);

        var randomBytes = ArrayPool<byte>.Shared.Rent(byteCount);
        try
        {
            GenerateRandomBytes(randomBytes, byteCount);

            return WebEncoders.Base64UrlEncode(randomBytes.AsSpan().Slice(0, byteCount));
        }
        finally
        {
            ArrayPool<byte>.Shared.Return(randomBytes, clearArray: true);
        }
    }

    /// <summary>
    /// Decodes a string generated by the <see cref="GenerateRandomBase64UrlEncodedString(int)"/> method.
    /// </summary>
    /// <param name="base64UrlEncoded">A base64 url-encoded string to decode. Must not be null.</param>
    public static byte[] DecodeBase64UrlEncodedString(string base64UrlEncoded)
    {
        ArgumentNullException.ThrowIfNull(base64UrlEncoded);

        return WebEncoders.Base64UrlDecode(base64UrlEncoded);
    }

    /// <summary>
    /// Generate a cryptographically-strong array of random bytes and return them as a base64-encoded string. 
    /// </summary>
    /// <remarks>The underlying <see cref="Convert.ToBase64String(ReadOnlySpan{byte}, Base64FormattingOptions)"/> leaves
    /// any padding intact.</remarks>
    /// <param name="byteCount">The number of random bytes to generate.</param>
    /// <returns>The random bytes as a base64-encoded string.</returns>
    public static string GenerateRandomBase64EncodedString(int byteCount)
    {
        ArgumentOutOfRangeException.ThrowIfLessThanOrEqual(byteCount, 0);

        var randomBytes = ArrayPool<byte>.Shared.Rent(byteCount);
        try
        {
            GenerateRandomBytes(randomBytes, byteCount);

            return Convert.ToBase64String(randomBytes.AsSpan().Slice(0, byteCount));
        }
        finally
        {
            ArrayPool<byte>.Shared.Return(randomBytes, clearArray: true);
        }
    }

    /// <summary>
    /// Decodes a string generated by the <see cref="GenerateRandomBase64EncodedString(int)"/> method.
    /// </summary>
    /// <param name="base64Encoded">A base64 encoded string to decode. Must not be null.</param>
    public static byte[] DecodeBase64EncodedString(string base64Encoded)
    {
        ArgumentNullException.ThrowIfNull(base64Encoded);

        return Convert.FromBase64String(base64Encoded);
    }

    /// <summary>
    /// Generates a cryptographically-strong array of random bytes and return them encoded as a string that
    /// can contain the characters in [A-Z0-9].
    /// </summary>
    /// <param name="length">The length of the random string to generate.</param>
    /// <returns>The random bytes encoded as a string that can contain the characters in [A-Z0-9].</returns>
    public static string GenerateUppercaseAlphanumericString(int length)
    {
        ArgumentOutOfRangeException.ThrowIfLessThanOrEqual(length, 0);

        return RandomNumberGenerator.GetString(_uppercaseAlphanumeric, length);
    }

    /// <summary>
    /// Generate a cryptographically-strong array of random bytes and return them encoded as a string that
    /// can contain the characters in [a-zA-Z0-9-_].
    /// </summary>
    /// <param name="length">The length of the random string to generate.</param>
    /// <returns>The random bytes encoded as a string that can contain the characters in [a-zA-Z0-9-_].</returns>
    public static string GenerateAlphanumericString(int length, bool includeDashAndUnderscore = true)
    {
        ArgumentOutOfRangeException.ThrowIfLessThanOrEqual(length, 0);

        return includeDashAndUnderscore
            ? RandomNumberGenerator.GetString(_alphanumericPlusDashUnderscore, length)
            : RandomNumberGenerator.GetString(_alphanumeric, length);
    }

    /// <summary>
    /// Generate a cryptographically-strong array of random bytes and return them encoded as a string that
    /// can contain the characters in [a-zA-Z0-9-_], as well as the various symbol characters.
    /// </summary>
    /// <param name="length">The length of the random string to generate.</param>
    /// <returns>The random bytes encoded as a string that can contain the characters in [a-zA-Z0-9-_], as 
    /// well as the various symbol characters.</returns>
    public static string GenerateRandomString(int length)
    {
        ArgumentOutOfRangeException.ThrowIfLessThanOrEqual(length, 0);

        return RandomNumberGenerator.GetString(_alphanumericPlusSymbols, length);
    }


    //
    // Private methods
    //

    /// <summary>
    /// Fills a span with cryptographically strong random bytes.
    /// </summary>
    private static void GenerateRandomBytes(Span<byte> buffer, int length)
    {
        // A pooled array is likely larger than the requested size. Only generate the requested number
        //   of bytes.
        RandomNumberGenerator.Fill(buffer.Slice(0, length));
    }
}
